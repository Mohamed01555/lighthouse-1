# -*- coding: utf-8 -*-
"""Model_OOP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EltssuA0Fa_uX_ZRBbf51EtxqPmTt6XT
"""

#!pip install insightface
#!pip install mxnet

import insightface
from PIL import Image
from numpy import asarray, dot
from matplotlib import pyplot as plt
from numpy.linalg import norm
import cv2

model = insightface.app.FaceAnalysis(det_name='retinaface_mnet025_v2',rec_name='arcface_r100_v1', ga_name=None)
model.prepare(ctx_id = -1, nms=0.4); #ctx_id = -1 to use CPU

class Model:
    def __init__(self):pass
        
    def prepare_image(self,filename):
        image = Image.open(filename).convert('RGB')
        pixels = asarray(image)
        return pixels

    def get_face_info(self, pixels):
        '''This function takes an image and extracts
        laocation of faces in the image and normed embedding of them.
        InsightFace performs both extraction and embedding.
        '''
        return model.get(pixels)

    def embed(self, image):
        """Returns the embedding of face or faces in the image."""

        pixels = self.prepare_image(image)
        results = self.get_face_info(pixels) 
        #TODO: fixing problem of multiple faces in the same photo
        # if len(results) > 1:
        #     raise Exception('There are many faces in the input image, so crop the face of the missing one')
        #     # print('Please select the face that you expect that it is the missing people, Enter the face number')
        #     index2emb_dict = self.plot_bounding_box(pixels, results)
        #     return index2emb_dict
        # else:
        return results[0].normed_embedding

    def plot_bounding_box(self, pixels, results):
        '''This function will not be called if there is a single face in the image'''

        font = cv2.FONT_HERSHEY_SIMPLEX
        index2emb_dict = {}
        for index, face in enumerate(results):
            x_min, y_min, x_max, y_max = face.bbox
            x_min, y_min, x_max, y_max = int(x_min), int(y_min), int(x_max), int(y_max)

            t = cv2.rectangle(pixels, (x_min, y_min), (x_max, y_max), (255,0,0), 2) #to draw a bounding box around a face
            cv2.putText(pixels, str(index), ((x_min+x_max)//2, (y_min+y_max)//2), font, 2, (0,0,255), 2, cv2.LINE_AA) #to write a text on a bounding box

            index2emb_dict[index] = face.normed_embedding

        plt.imshow(t)
        plt.show()
        return index2emb_dict
    
    def get_similarity(self, face1, face2):
        face1_emb = self.embed(face1)
        face2_emb = self.embed(face2)
        cos_sim = dot(face1_emb, asarray(face2_emb).T)
        return cos_sim

    #TODO: make imagesEmbeds dynamic 
    def find(self, imagesEmbeds , targetImageEmbed):pass
    
